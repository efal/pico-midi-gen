import { MidiComponent, ProjectConfig, ComponentType } from '../types';

export const generateArduinoCode = (config: ProjectConfig, components: MidiComponent[]): string => {
  const timestamp = new Date().toISOString().split('T')[0];

  let includes = '';

  // Check if we need Display includes
  if (components.some(c => c.type === ComponentType.SSD1306Display)) {
    includes += `#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n`;
  }

  includes += `#include <Control_Surface.h>\n`;

  let header = `/**
 * ${config.name}
 * Generated by PicoControl Gen on ${timestamp}
 * Author: ${config.author}
 * 
 * Board: Raspberry Pi Pico (RP2040)
 * Library: Control Surface by tttapa
 */\n\n`;

  let interfaceCode = '';
  if (config.interfaceType === 'USBMIDI_Interface') {
    interfaceCode = `// Instantiate a MIDI over USB interface
USBMIDI_Interface midi;`;
  } else {
    interfaceCode = `// Instantiate a Hardware Serial MIDI interface
HardwareSerialMIDI_Interface midi = {Serial1, ${config.baudRate || 31250}};`;
  }

  let componentsCode = `\n// --- MIDI Components ---`;

  // 1. Generate Multiplexers first
  const multiplexers = components.filter(c => c.type === ComponentType.Multiplexer);
  const otherComponents = components.filter(c => c.type !== ComponentType.Multiplexer);
  const displayDrivers: string[] = [];

  multiplexers.forEach(mux => {
    let safeName = mux.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    safeName += `_${mux.id.slice(-4)}`; // Ensure uniqueness
    if (/^\d/.test(safeName)) safeName = `comp_${safeName}`;

    const signalPin = mux.pins[0];
    const selectPins = mux.pins.slice(1).join(', ');

    componentsCode += `\n\n// Multiplexer: ${mux.name}
CD74HC4067 ${safeName} = {
  ${signalPin},      // Signal pin (Z)
  {${selectPins}}, // Select pins (S0, S1, S2, S3)
  // optional: enable pin
};`;
  });

  // 2. Generate other components
  otherComponents.forEach(comp => {
    let safeName = comp.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    safeName += `_${comp.id.slice(-4)}`; // Ensure uniqueness
    if (/^\d/.test(safeName)) safeName = `comp_${safeName}`;

    // Determine pin definition (Direct vs Multiplexed)
    let pinDef = '';
    if (comp.parentId) {
      const parentMux = multiplexers.find(m => m.id === comp.parentId);
      if (parentMux) {
        let parentName = parentMux.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
        parentName += `_${parentMux.id.slice(-4)}`;
        if (/^\d/.test(parentName)) parentName = `comp_${parentName}`;
        pinDef = `${parentName}.pin(${comp.muxPin})`;
      } else {
        pinDef = comp.pins.join(', '); // Fallback
      }
    } else {
      pinDef = comp.pins.join(', ');
    }

    componentsCode += `\n\n// ${comp.name}`;

    switch (comp.type) {
      case ComponentType.CCPotentiometer:
        componentsCode += `
CCPotentiometer ${safeName} = {
  ${pinDef}, // Analog Pin or Mux Pin
  {MIDI_CC::General_Purpose_Controller_1 + ${comp.address}, Channel_${comp.channel}},
};`;
        break;

      case ComponentType.NoteButton:
        componentsCode += `
NoteButton ${safeName} = {
  ${pinDef}, // Digital Pin or Mux Pin
  {${comp.address}, Channel_${comp.channel}}, // Note number, Channel
};`;
        break;

      case ComponentType.CCButton:
        componentsCode += `
CCButton ${safeName} = {
  ${pinDef}, // Digital Pin or Mux Pin
  {MIDI_CC::General_Purpose_Controller_1 + ${comp.address}, Channel_${comp.channel}},
};`;
        break;

      case ComponentType.CCRotaryEncoder:
        // Encoders often need a speed multiplier, hardcoded to 1 for now or optional
        componentsCode += `
CCRotaryEncoder ${safeName} = {
  {${comp.pins[0]}, ${comp.pins[1]}}, // Pins A, B
  {MIDI_CC::General_Purpose_Controller_1 + ${comp.address}, Channel_${comp.channel}},
  1, // Speed multiplier
};`;
        break;

      case ComponentType.NoteLED:
        componentsCode += `
NoteLED ${safeName} = {
  ${pinDef}, // Pin
  {${comp.address}, Channel_${comp.channel}}, // Note number, Channel
};`;
        break;

      case ComponentType.PBPotentiometer:
        componentsCode += `
PBPotentiometer ${safeName} = {
  ${pinDef}, // Analog Pin
  Channel_${comp.channel},
};`;
        break;

      case ComponentType.ButtonMatrix:
        const rows = (comp.rowPins || []).join(', ');
        const cols = (comp.colPins || []).join(', ');
        const rowCount = (comp.rowPins || []).length;
        const colCount = (comp.colPins || []).length;

        // Generate a simple chromatic map for the matrix starting at 'address'
        // AddressMatrix is Array<Array<uint8_t, C>, R>
        // Needs double braces {{ {{...}}, {{...}} }}
        let noteMap = '{{\n';
        for (let r = 0; r < rowCount; r++) {
          noteMap += '    {{';
          for (let c = 0; c < colCount; c++) {
            const noteNum = comp.address + (r * colCount) + c;
            noteMap += `${noteNum}, `;
          }
          noteMap += '}},\n';
        }
        noteMap += '  }}';

        componentsCode += `
// Dimensions: ${rowCount}x${colCount}
const Array<pin_t, ${rowCount}> ${safeName}_rows = {{ ${rows} }};
const Array<pin_t, ${colCount}> ${safeName}_cols = {{ ${cols} }};

// Note Map
const AddressMatrix<${rowCount}, ${colCount}> ${safeName}_notes = ${noteMap};

NoteButtonMatrix<${rowCount}, ${colCount}> ${safeName} = {
  ${safeName}_rows,
  ${safeName}_cols,
  ${safeName}_notes,
  Channel_${comp.channel},
};`;
        break;

      case ComponentType.CCButtonMatrix:
        const ccRows = (comp.rowPins || []).join(', ');
        const ccCols = (comp.colPins || []).join(', ');
        const ccRowCount = (comp.rowPins || []).length;
        const ccColCount = (comp.colPins || []).length;

        // Generate a simple linear map for the matrix starting at 'address'
        let ccMap = '{{\n';
        for (let r = 0; r < ccRowCount; r++) {
          ccMap += '    {{';
          for (let c = 0; c < ccColCount; c++) {
            const ccNum = comp.address + (r * ccColCount) + c;
            ccMap += `${ccNum}, `;
          }
          ccMap += '}},\n';
        }
        ccMap += '  }}';

        componentsCode += `
// Dimensions: ${ccRowCount}x${ccColCount}
const Array<pin_t, ${ccRowCount}> ${safeName}_rows = {{ ${ccRows} }};
const Array<pin_t, ${ccColCount}> ${safeName}_cols = {{ ${ccCols} }};

// CC Map
const AddressMatrix<${ccRowCount}, ${ccColCount}> ${safeName}_cc = ${ccMap};

CCButtonMatrix<${ccRowCount}, ${ccColCount}> ${safeName} = {
  ${safeName}_rows,
  ${safeName}_cols,
  ${safeName}_cc,
  Channel_${comp.channel},
};`;
        break;

      case ComponentType.SSD1306Display:
        // Basic SSD1306 setup
        componentsCode += `
// SSD1306 Display
Adafruit_SSD1306 ${safeName}_driver(128, 64, &Wire, -1);
`;
        displayDrivers.push(`${safeName}_driver`);
        break;
    }
  });

  // Generate setupDisplay function if needed
  if (displayDrivers.length > 0) {
    componentsCode += `\n
void setupDisplay() {
${displayDrivers.map(driver => `    ${driver}.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    ${driver}.clearDisplay();
    ${driver}.display();`).join('\n')}
}`;
  }

  const setupCode = `
void setup() {
  Control_Surface.begin(); // Initialize Control Surface
  ${components.some(c => c.type === ComponentType.SSD1306Display) ? 'setupDisplay();' : ''}
}
`;

  const loopCode = `
void loop() {
  Control_Surface.loop(); // Update the Control Surface
}
`;

  return `${includes}${header}${interfaceCode}${componentsCode}\n${setupCode}${loopCode}`;
};